{
  "name": "Emeus",
  "tagline": "Constraint-based layout manager for GTK+",
  "body": "## Emeus - Constraint-based layout manager for GTK+\r\n\r\n### What is Emeus?\r\n\r\nEmeus is a constraint-based layout manager widget for [GTK+][gtk-web],\r\nwritten using the [Cassowary][cassowary-web] constraint solving algorithm.\r\n\r\n### What's the difference between Emeus and GTK+'s layout managers?\r\n\r\nGTK+ has two different sorts of layout managers:\r\n\r\n * the boxes-inside-boxes model, represented by [GtkBox][gtk-box-api] and\r\n   which is the preferred layout management mechanism\r\n * the fixed positioning and sizing model, using the [GtkFixed][gtk-fixed-api]\r\n   and the [GtkLayout][gtk-layout-api] containers\r\n\r\nThe first model works really well in ensuring that UIs are responsive to\r\nsize changes, by avoiding pixel-perfect positioning on the screen, as well\r\nas ensuring that changing the font size or margins and paddings do not break\r\nthe user interface; its main down side is that it requires accurate, and\r\noften verbose packing of widgets inside boxes, inside other boxes.\r\n\r\nThe second model allows a more efficient way to construct a user interface,\r\nat the major costs of either \"freezing\" it, or requiring constant\r\nrecalculations of the relative position and size of each UI element.\r\n\r\nEmeus provides a third layout management policy, based on *constraints*;\r\neach UI element binds one of more of its attributes — like its width, or its\r\nposition — to other UI elements, in a way that is more natural to describe\r\nfrom a UI building perspective, and hopefully more efficient that stacking\r\npiles of boxes one inside another.\r\n\r\n### Constraints\r\n\r\n`EmeusLayoutConstraint` is a [GtkContainer][gtk-container-api] that can\r\nsupport multiple children; each child, in turn, is associated to one or more\r\n`EmeusConstraint` instances. Each constraint is the expression of a simple\r\nlinear equation:\r\n\r\n    item1.attr1 = item2.attr2 × multiplier + constant\r\n\r\nWhere:\r\n\r\n  * `item1` is the target widget, that is the widget we want to constraint;\r\n    if unset, the target will be the layout itself\r\n  * `attr1` is an attribute of the target widget, like `width` or `end`,\r\n    that we want to constraint\r\n  * `item2` is the source widget, that is the widget that provides the value\r\n    of the constraint; if unset, the source will be the layout itself\r\n  * `attr2` is an attribute of the source widget that provides the value\r\n    of the constraint\r\n  * `multiplier` is a multiplication factor, expressed as a floating point\r\n    value\r\n  * `constant` is an additional constant factor, expressed as a floating\r\n    point value\r\n\r\nUsing both notations, then, we can construct user interfaces like:\r\n\r\n    +-------------------------------------------+\r\n    |   [ button 1 ] [ button 2 ] [ button 3]   |\r\n    +-------------------------------------------+\r\n\r\nBy expressing the constraints between the UI elements. For instance, we can\r\ncenter `button2` within its parent and give it a minimum width of 250\r\nlogical pixels:\r\n\r\n    button2.width >= 250\r\n    button2.centerX = parent.centerX\r\n    button2.centerY = parent.centerY\r\n\r\nThen, we can tie `button1` and `button3` to `button2`, and ensure that the\r\nwidth and height of all three buttons are the same:\r\n\r\n    button1.end = button2.start - 8\r\n    button1.width = button2.width\r\n    button1.height = button2.height\r\n\r\n    button3.start = button2.end + 8\r\n    button3.width = button2.width\r\n    button3.height = button2.height\r\n\r\nThe `EmeusConstraintLayout` widget will attempt to resolve all the\r\nconstraints, and lay out its children according to them.\r\n\r\n## Building\r\n\r\n * Install [meson](http://mesonbuild.com/)\r\n * Install [ninja](https://ninja-build.org/)\r\n * Create a build directory:\r\n  * `$ mkdir _build && cd _build`\r\n * Run meson:\r\n  * `$ meson ..`\r\n * Run ninja:\r\n  * `$ ninja`\r\n\r\n## Licensing\r\n\r\nEmeus is released under the terms of the GNU Lesser General Public License,\r\neither version 2.1 or, at your option, any later version.\r\n\r\nThe Cassowary simplex solving algorithm implementation is largely inspired\r\nby the equivalent implementations written in various other language,\r\nincluding:\r\n\r\n * [Cassowary][cassowary-web] — the original C++ implementation, released\r\n   under the terms of the GNU Lesser General Public License, version 2.1 or\r\n   later\r\n * [Cassowary.js][cassowary-js-web] — JavaScript implementation, released\r\n   under the terms of the Apache License, Version 2.0\r\n * [Cassowary][cassowary-py-web] — Python implementation, released under the\r\n   terms of the BSD 3-clause license\r\n\r\nAdditionally, the automatic layout solving is inspired by\r\n[autolayout.js][autolayout-js-web], a JavaScript automatic constraint-based\r\nlayout, which, in turn, is based on the Apple [autolayout][nsautolayout-web]\r\nlayout manager.\r\n\r\nYou can check on the [Overconstrained][overconstrained-web] website for\r\nadditional Cassowary implementations in various languages.\r\n\r\n[gtk-web]: https://www.gtk.org\r\n[cassowary-web]: http://constraints.cs.washington.edu/cassowary/\r\n[overconstrained-web]: http://overconstrained.io/\r\n[gtk-container-api]: https://developer.gnome.org/gtk3/stable/GtkContainer.html\r\n[gtk-fixed-api]: https://developer.gnome.org/gtk3/stable/GtkFixed.html\r\n[gtk-layout-api]: https://developer.gnome.org/gtk3/stable/GtkLayout.html\r\n[gtk-box-api]: https://developer.gnome.org/gtk3/stable/GtkBox.html\r\n[cassowary-cpp-web]: https://sourceforge.net/projects/cassowary/\r\n[cassowary-js-web]: https://github.com/slightlyoff/cassowary.js\r\n[cassowary-py-web]: https://github.com/pybee/cassowary\r\n[autolayout-js-web]: https://github.com/IjzerenHein/autolayout.js\r\n[nsautolayout-web]: https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}